# What is Talisman?
Talisman is a tool that installs a hook to your repository to ensure that potential secrets or sensitive information do not leave the developer's workstation.

It validates the outgoing changeset for things that look suspicious - such as potential SSH keys, authorization tokens, private keys etc.

# Installation
Talisman supports MAC OSX, Linux and Windows.

Talisman can be set up as either a pre-commit or pre-push hook on the git repositories.

You can choose to install Talisman in one of the following ways:

1. As a global installation : This is the RECOMMENDED approach. In this way, Talisman will install as a git hook as a global git hook template on the machine and a CLI utility, which can also be used for git repo scanning. The git hook can be set up for either a pre-commit or a pre-push configuration.
2. As a hook for a single repository : This approach will install Talisman as a pre-push hook to a single repository. You will have to take extra manual steps to extend Talisman as a repository scanner, beyond a pre-push git hook.


## [Recommanded Approach]
## Installation as a global hook template
We recommend installing Talisman as a **pre-commit git hook template**, as that will cause Talisman to be present, not only in your existing git repositories, but also in any new repository that you 'init' or 'clone'.
1. Run the following command on your terminal, to download and install the binary at $HOME/.talisman/bin

  As a pre-commit hook:

  ```
  bash -c "$(curl --silent https://thoughtworks.github.io/talisman/scripts/install.bash)"
  ```
  OR

  As a pre-push hook:

  ```
  bash -c "$(curl --silent https://thoughtworks.github.io/talisman/scripts/install.bash)" -- pre-push
  ```

2. If you do not have TALISMAN_HOME set up in your $PATH, you will be asked an appropriate place to set it up. Choose the option number where you set the profile source on your machine.
Remember to execute source on the path file or restart your terminal. If you choose to set the $PATH later, add export TALISMAN\_HOME=$HOME/.talisman/bin to the path.

3. Choose a base directory where Talisman should scan for all git repositories, and setup a pre-commit hook as chosen in step 1 as a symlink.

# Talisman in action

After the installation is successful, Talisman will run checks for obvious secrets automatically before each commit or push (as chosen during installation). In case there are any security breaches detected, talisman will display a detailed report of the errors:

```bash
$ git push
Talisman Report:
+-----------------+-------------------------------------------------------------------------------+
|     FILE        |                                    ERRORS                                     |
+-----------------+-------------------------------------------------------------------------------+
| danger.pem      | The file name "danger.pem"                                                    |
|                 | failed checks against the                                                     |
|                 | pattern ^.+\.pem$                                                             |
+-----------------+-------------------------------------------------------------------------------+
| danger.pem      | Expected file to not to contain hex encoded texts such as:                    |
|                 | awsSecretKey=c64e8c79aacf5ddb02f1274db2d973f363f4f553ab1692d8d203b4cc09692f79 |
+-----------------+-------------------------------------------------------------------------------+
```

In the above example, the file *danger.pem* has been flagged as a security breach due to the following reasons:

* The filename matches one of the pre-configured patterns.
* The file contains an awsSecretKey which is scanned and flagged by Talisman

If you have installed Talisman as a pre-commit hook, it will scan only the _diff_ within each commit. This means that it would only report errors for parts of the file that were changed.

In case you have installed Talisman as a pre-push hook, it will scan the complete file in which changes are made. As mentioned above, it is recommended that you use Talisman as a **pre-commit hook**.

## Validations
The following detectors execute against the changesets to detect secrets/sensitive information:

* **Encoded values** - scans for encoded secrets in Base64, hex etc.
* **File content** - scans for suspicious content in file that could be potential secrets or passwords
* **File size** - scans for large files that may potentially contain keys or other secrets
* **Entropy** - scans for content with high entropy that are likely to contain passwords. (Entropy is a state of disorder, randomness, or uncertainty.)
* **Credit card numbers** - scans for content that could be potential credit card numbers
* **File names** - scans for file names and extensions that could indicate them potentially containing secrets, such as keys, credentials etc.

## Ignoring Files

If you're *really* sure you want to push that file, you can configure it into the `.talismanrc` file in the project root. The contents required for ignoring your failed files will be printed by Talisman on the console immediately after the Talisman Error Report:

```bash
If you are absolutely sure that you want to ignore the above files from talisman detectors, consider pasting the following format in .talismanrc file in the project root
fileignoreconfig:
- filename: danger.pem
  checksum: cf97abd34cebe895417eb4d97fbd7374aa138dcb65b1fe7f6b6cc1238aaf4d48
  ignore_detectors: []
```
Entering this in the `.talismanrc` file will ensure that Talisman will ignore the `danger.pem` file as long as the checksum matches the value mentioned in the `checksum` field. (If .talismanrc doesn't exist, you should create one.)

More detailed configuration can be found here: 
https://github.com/thoughtworks/talisman#ignoring-files

## Bypass/Skip Talisman Hooks 
`git push origin --no-verify`

## Example Files
```
mkdir sec_files && cd sec_files
echo "username=sidd-harth" > file1
echo "secure-password123" > password.txt
echo "apikey=AizaSyCqhjgrPtr_La56sdUkjfav_laCqhjgrPtr_2s" > file2
echo "base64encodedsecret=cGFzc3dvcmQtaXMtcXdlcnR5MTIzCg==" > file3
```
# Talisman as a CLI utility
1. Install Talisman cli for Mac:
```
brew install talisman
```
2. Scan the repository and generate talisman reports
```
talisman --scan --reportDirectory /home/username/Desktop/
```

# Uninstallation
## Uninstallation from a global hook template
Run the following command on your terminal to uninstall talisman globally from your machine.
For pre-commit hook:
```
bash -c "$(curl --silent https://thoughtworks.github.io/talisman/scripts/uninstall.bash)"
```
For pre-push hook:

```
bash -c "$(curl --silent https://thoughtworks.github.io/talisman/scripts/uninstall.bash)" -- pre-push
```

This will

1. ask you for the base dir of all your repos, find all git repos inside it and remove talisman hooks
2. remove talisman hook from .git-template
3. remove talisman from the central install location ($HOME/.talisman/bin).<br>

<i>You will have to manually remove TALISMAN_HOME from your environment variables</i>

# What we should do?
1. Install talisman as a global pre-commit hook as instructed above
2. Since talisman pre-commit only report errors for parts of the file that were changed and now our repository are good, we have a clean base without any .talimanrc. If talisman detects some files during the commit stage, and you are sure that the changes are necessary, then follow the above steps of **ignoring files**  to edit the .talismanrc file. Then you will be able to commit the change.
.talimanrc is created at the root of each project repository. Therefore, there will be different talisman configuration for each project.

Reference
https://thoughtworks.github.io/talisman/docs